If you want to change what Codex should build (vs the earlier “full UI” request), use the **Update** button on that task prompt.

Below is the **documentation/spec** you can paste into your repo (e.g. `docs/UI_CODEX_SPEC.md`) and then hand to Codex to implement.

---

# CortexOS Studio UI (macOS‑style) — Codex Implementation Spec v1

## 0) Context and constraints (source of truth)

CortexOS already exposes a dashboard-capable API Gateway and a real-time stream. The UI must be built around these endpoints and conventions:

### Backend interface the UI must use

* REST:

  * `GET /health`
  * `GET /api/v1/workers`
  * `GET /api/v1/jobs`
  * `GET /api/v1/jobs/:id`
  * `POST /api/v1/jobs` with JSON `{prompt, topic}`
  * `GET /api/v1/traces/:id`
* Real-time:

  * `WS /api/v1/stream` = WebSocket stream of `BusPacket` events (camelCase JSON) 

### Auth requirements

If gateway env `API_KEY` is set:

* All HTTP requests include `X-API-Key: <value>`
* WS uses the same key via header and/or query param; the repo docs specify UI should append `api_key` automatically 

### UI env variables

UI runs locally with:

* `VITE_API_BASE=http://localhost:8081`
* `VITE_WS_BASE=ws://localhost:8081/api/v1/stream`
* `VITE_API_KEY=<same as API_KEY>` (optional) 

---

## 1) Goal of this UI

Build **CortexOS Studio**: a macOS-inspired “Control Room + Workflow Studio”.

### Must-have pages (v1)

1. **Dashboard** (Mission Control + Worker Mesh + Live Feed)
2. **Workflows** (drag/drop workflow builder + inspector)
3. **Runs** (workflow run history, even if local-only)
4. **Jobs** (job list + job detail)
5. **Traces** (trace lookup + trace job list)
6. **Workers** (worker list + load/capacity)
7. **Chat** (submit job + view live results)
8. **Settings** (API base / WS / API key, stored locally)

This matches the “Control Room” intent and endpoint wiring described in the repo dashboard doc. 

### Non-goals (v1)

* No server-side workflow template CRUD (unless backend exists)
* No full BPMN engine (branch/parallel can be UI-only or “disabled” in v1)
* No RBAC UI

---

## 2) UX: macOS-style app shell

The UI should feel like a native macOS app:

### Layout (global)

* **Top toolbar** (glass/vibrancy)

  * Left: “traffic lights” (decorative), title “CortexOS Studio”
  * Center: Command palette search (`⌘K`)
  * Right: Connection status (REST + WS), environment badge
* **Left sidebar** (translucent)

  * Dashboard / Workflows / Runs / Jobs / Traces / Workers / Chat / Settings
* **Main content** (page)
* **Right Inspector panel** (toggle)

  * Shows details for selected workflow node / selected job / selected worker

### Interaction rules

* Keep canvas clean; all config/editing happens in **Inspector**
* Keyboard:

  * `⌘K`: command palette
  * `Esc`: close palettes/modals
  * `Space + drag`: pan workflow canvas
  * `Delete`: delete selected workflow node

---

## 3) Design system (macOS glass + dark)

### Theme target

* Base is “dark + glass” (macOS Sonoma/Sequoia feel)
* Use subtle blur + transparency:

  * `backdrop-blur-xl`
  * `bg-white/5` / `bg-black/30`
  * `border-white/10`
  * `shadow-[...]` soft, not harsh
* Typography:

  * `Inter` for UI
  * Monospace for IDs/pointers

The existing repo dashboard design mentions dark mode and Inter/mono; keep that but make it macOS glass. 

### UI primitives (components Codex must create)

* `AppShell`
* `SidebarNav`
* `TopBar`
* `Card` (glass)
* `Badge` (status)
* `KpiCard`
* `DataTable`
* `InspectorPanel`
* `CommandPalette`
* `JsonViewer` (pretty JSON view)
* `LoadingSkeleton`
* `EmptyState`
* `Toast`

### Status colors mapping

Use canonical job state machine terms from scheduler spec:

* `PENDING, SCHEDULED, DISPATCHED, RUNNING, SUCCEEDED, FAILED, CANCELLED, TIMEOUT, DENIED` 

---

## 4) Data model the UI should assume

### Worker (from /workers)

The scheduler’s heartbeat contract includes:

* `worker_id`, `region`, `type`
* `cpu_load`, `gpu_utilization`, `active_jobs`
* `capabilities`
* `pool`, `max_parallel_jobs` 

UI can render worker cards from these fields (or a subset).

### Job (from /jobs and /jobs/:id)

Assume at minimum:

* `job_id`, `topic`, `state/status`
* `trace_id` (if available)
* `context_ptr`, `result_ptr`
* timestamps
* optional: `worker_id`, `execution_ms`, `error`

Pointer conventions are:

* context key: `ctx:<job_id>` and pointer `redis://ctx:<job_id>`
* result key: `res:<job_id>` and pointer `redis://res:<job_id>` 

### Stream events (WS /api/v1/stream)

The stream sends `BusPacket` events. UI must:

* parse JSON
* detect payload type (jobRequest/jobResult/heartbeat/alert)
* summarize into a “console line”
* keep last N events in memory

“Agents communicate via BusPacket envelopes + Redis pointers” is the system model. 

---

## 5) Page specifications

### 5.1 Dashboard (Mission Control)

**Purpose:** At-a-glance system state + live feed.

**UI blocks**

1. KPI row:

* Active jobs count
* Completed jobs count
* Workers online count
* Events received count (from WS)

2. Live Feed panel:

* streaming list of events with compact formatting
* filter by: topic/pool/job_id

3. Worker Mesh preview:

* small grid of worker cards (top N)

4. Recent Jobs preview:

* latest jobs table (top N)
* clicking opens Job detail

Matches repo dashboard “Mission Control / Worker Mesh / Job Explorer / Chat” concept. 

**Data**

* poll `/api/v1/workers` and `/api/v1/jobs`
* WS feed from `/api/v1/stream` 

---

### 5.2 Workers

**Purpose:** Compute plane view.

**UI blocks**

* table/grid toggle
* worker cards show:

  * worker_id, pool, region/type
  * cpu/gpu utilization bars
  * active_jobs / max_parallel_jobs
  * status (online/offline inferred from last heartbeat timestamp if provided; otherwise “unknown”)

**Data**

* `GET /api/v1/workers` 

---

### 5.3 Jobs

**Purpose:** traceability + deep inspection.

**Jobs list**

* search by job_id
* filter by state, topic
* show columns:

  * job_id (copy)
  * topic
  * state badge
  * trace_id (clickable)
  * ctx/result pointers (redis://ctx:<job_id>, redis://res:<job_id>)
  * started/updated
  * worker_id (if present)

**Job detail**

* summary header: job_id + state + topic + trace_id
* tabs:

  * Overview
  * Context (fetch JSON payload if API returns)
  * Result (render JSON)
  * Events (if WS retained and can filter)
* show pointers:

  * context_ptr / result_ptr
  * pointer viewer: allow fetching the raw Redis value via `GET /api/v1/memory?ptr=<redis://...>` (render as JSON/text/base64)

Repo doc explicitly says “Job Explorer” uses `/api/v1/jobs` and job detail shows pointers. 

---

### 5.4 Traces

**Purpose:** See all jobs in a trace.

**UI**

* input trace_id + “Load”
* list of jobs returned by trace endpoint
* optional: simple DAG visualization if parent/child is included, otherwise chronological list

**Data**

* `GET /api/v1/traces/:id` 

---

### 5.5 Chat

**Purpose:** direct job submission.

**UI**

* chat transcript area
* input prompt box
* topic dropdown (default: `job.chat.simple`)
* submit calls `POST /api/v1/jobs` with `{prompt, topic}` 
* show “thinking” state until result arrives
* optionally listen for job completion via:

  * WS feed (preferred), or
  * polling job detail endpoint

---

## 6) Workflow Studio (drag & drop) — core new feature

### 6.1 Requirements

* Canvas = drag/drop nodes, connect edges
* Palette = node library
* Inspector = config selected node
* Save workflows locally (v1)
* Run workflow locally (v1), using existing job submission endpoint
* In “Run mode”, nodes show live state badges

### 6.2 Node types (v1)

**Task Node** (required)

* fields:

  * `name`
  * `topic` (examples below)
  * `promptTemplate` (supports variables)
  * `timeoutMs` (UI-only setting)
  * `retries` (UI-only setting)

**Input Node** (required)

* defines workflow inputs:

  * `input.prompt`
  * `input.filePath` (optional)
  * `input.instruction` (optional)

**Output Node** (required)

* defines output mapping (what to show at end)

**Control nodes** (optional v1, okay to ship “disabled”)

* If/Else
* Parallel + Join
* ForEach

### 6.3 Topics to include as defaults (from current pools)

From current pool spec, the system supports:

* `job.echo`
* `job.chat.simple`
* `job.chat.advanced`
* `job.code.llm`
* `job.workflow.demo` 

Also, current workflows include `job.workflow.demo` and optional planner `job.workflow.plan`. 
Planner toggle exists via `USE_PLANNER` in compose. 

### 6.4 Workflow persistence (v1)

* Save to `localStorage`:

  * key: `cortexos.workflows.v1`
* Workflow JSON schema:

  * `{ id, name, updatedAt, nodes: [], edges: [], variablesSchema: {} }`

### 6.5 Variable mapping (v1)

Prompt templates support:

* `${input.prompt}`
* `${node.<nodeId>.result.<path>}` (best-effort)
* `${prev.result}` (shortcut for sequential execution)

### 6.6 Run execution model (v1)

Because no server-side workflow API is specified, implement “client runner”:

Algorithm:

1. Topologically sort Task nodes from start → end
2. For each Task node:

   * render prompt = template with variables
   * submit job: `POST /api/v1/jobs {prompt, topic}`
   * poll `GET /api/v1/jobs/:id` until terminal
   * store node result in `runState.nodeResults[nodeId]`
3. render output summary in Run detail page

Node states must follow canonical names (so UI matches scheduler states). 

### 6.7 Run history (v1)

* store runs locally:

  * key: `cortexos.runs.v1`
* each run stores:

  * workflowId
  * startedAt/endedAt
  * per-node job_id, topic, state, result snapshot (optional)
  * trace_ids if returned by API

---

## 7) Technical implementation (Codex should follow)

### 7.1 Folder target

Create (or recreate) UI under:

* `web/dashboard/`

Repo docs already use this folder for dashboard. 

### 7.2 Stack

* React + Vite + TypeScript
* Tailwind CSS
* Lucide icons (already referenced in docs) 
* React Router
* TanStack Query (recommended) for REST polling
* Zustand (recommended) for UI state (inspector open, selected node)
* React Flow for workflow canvas

### 7.3 Required modules to implement

**API client**

* `src/lib/api.ts`

  * base url from `VITE_API_BASE`
  * attach `X-API-Key` when `VITE_API_KEY` set

**WS client**

* `src/lib/ws.ts`

  * connect to `VITE_WS_BASE` OR derive from API base
  * if API key exists, append `?api_key=...`
  * auto reconnect with exponential backoff
  * provide typed event stream subscription

**Data hooks**

* `useWorkers()`, `useJobs()`, `useJob(jobId)`, `useTrace(traceId)`

---

## 8) Suggested file tree (Codex should create)

```txt
web/dashboard/
  src/
    app/
      App.tsx
      routes.tsx
      AppShell.tsx
      TopBar.tsx
      Sidebar.tsx
      Inspector.tsx
      CommandPalette.tsx
    lib/
      env.ts
      api.ts
      ws.ts
      format.ts
      storage.ts
    state/
      inspectorStore.ts
      streamStore.ts
      workflowStore.ts
      runStore.ts
    components/
      Card.tsx
      Badge.tsx
      KpiCard.tsx
      DataTable.tsx
      JsonViewer.tsx
      Loading.tsx
      EmptyState.tsx
    pages/
      DashboardPage.tsx
      WorkersPage.tsx
      JobsPage.tsx
      JobDetailPage.tsx
      TracesPage.tsx
      WorkflowsPage.tsx
      RunsPage.tsx
      RunDetailPage.tsx
      ChatPage.tsx
      SettingsPage.tsx
    features/
      workflows/
        WorkflowCanvas.tsx
        nodeTypes/
          TaskNode.tsx
          InputNode.tsx
          OutputNode.tsx
        inspector/
          TaskInspector.tsx
          InputInspector.tsx
          OutputInspector.tsx
        runner/
          runWorkflow.ts
```

---

## 9) Codex execution plan (tasks + acceptance criteria)

### Task A — Bootstrap + shell

**Do**

* create Vite React TS app in `web/dashboard`
* Tailwind setup
* AppShell layout with sidebar + topbar + inspector

**Accept**

* can navigate between pages without errors
* shell is glass-themed

### Task B — API + WS plumbing

**Do**

* implement `api.ts` and `ws.ts`
* implement Settings to store base url + key in localStorage and allow env defaults
* show connection status in topbar

**Accept**

* `/health` check updates “Connected” indicator
* WS connects and prints incoming events to console feed

### Task C — Dashboard page

**Do**

* KPIs (workers count, jobs count, events count)
* Live Feed (from WS)
* Worker Mesh preview + Recent Jobs preview

**Accept**

* shows items when backend is up and jobs run

### Task D — Workers, Jobs, Traces

**Do**

* Workers page from `/api/v1/workers`
* Jobs list from `/api/v1/jobs`
* Job detail from `/api/v1/jobs/:id`
* Traces view from `/api/v1/traces/:id`

**Accept**

* clicking a job shows pointers + payload JSON
* trace lookup returns list

### Task E — Chat

**Do**

* chat UI with topic dropdown
* submit via `POST /api/v1/jobs {prompt, topic}` 
* show updates via WS and/or polling

**Accept**

* can submit `job.chat.simple` and see completion

### Task F — Workflow Studio (builder)

**Do**

* implement WorkflowCanvas with React Flow
* Task/Input/Output nodes + inspector editors
* save/load workflows localStorage
* implement “Run workflow” client runner (sequential)
* store runs localStorage + show Runs page

**Accept**

* can build a 2-step workflow:

  1. `job.code.llm`
  2. `job.chat.simple`
* run it and see node states + final output

---

## 10) “Good defaults” (ship-ready UX)

* Provide workflow templates:

  * “Code Review + Explanation” template that mirrors current orchestrator idea (code-llm → chat-simple). 
* Provide topic dropdown defaults:

  * `job.chat.simple`, `job.chat.advanced`, `job.code.llm`, `job.echo` 
* Always show job pointers:

  * `context_ptr`, `result_ptr` naming as Redis pointers (important for debugging). 

---

## 11) Copy/paste Codex prompt (use this to run Codex)

> Implement `web/dashboard` as “CortexOS Studio UI” following `docs/UI_CODEX_SPEC.md`.
> Use the backend endpoints and env variables exactly as specified.
> Prioritize: AppShell + API/WS clients + Dashboard + Jobs/Workers/Traces + Workflow Builder (React Flow) + client-side workflow runner.
> Keep everything TypeScript, add basic error handling, loading states, and glassmorphism styling.

---

If you want, tell me your **new UI folder name** (e.g. `web/studio` vs `web/dashboard`) and I’ll rewrite the spec to match *exactly* where you want Codex to create files—without changing any backend assumptions.
